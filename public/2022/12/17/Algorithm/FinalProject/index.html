<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Huffman Algorithm and Greedy Method | ahui9605's blog</title><meta name="author" content="Zehui Liu"><meta name="copyright" content="Zehui Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ITS495 Special Topics Huffman Coding Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="Huffman Algorithm and Greedy Method">
<meta property="og:url" content="http://ahui9605.github.io/2022/12/17/Algorithm/FinalProject/index.html">
<meta property="og:site_name" content="ahui9605&#39;s blog">
<meta property="og:description" content="ITS495 Special Topics Huffman Coding Algorithm">
<meta property="og:locale">
<meta property="og:image" content="http://ahui9605.github.io/images/Logo/Algorithm_Logo.jpg">
<meta property="article:published_time" content="2022-12-17T05:00:00.000Z">
<meta property="article:modified_time" content="2022-12-22T04:45:25.852Z">
<meta property="article:author" content="Zehui Liu">
<meta property="article:tag" content="Articles">
<meta property="article:tag" content="Code">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ahui9605.github.io/images/Logo/Algorithm_Logo.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://ahui9605.github.io/2022/12/17/Algorithm/FinalProject/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Huffman Algorithm and Greedy Method',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-21 23:45:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/Categories/"><span> Category</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ahui9605's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/Categories/"><span> Category</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Huffman Algorithm and Greedy Method</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-17T05:00:00.000Z" title="Created 2022-12-17 00:00:00">2022-12-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-22T04:45:25.852Z" title="Updated 2022-12-21 23:45:25">2022-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithms/">Algorithms</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Huffman Algorithm and Greedy Method"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>A specific kind of optimum algorithm called a Huffman code is frequently employed for lossless data compression in computer science. This is a method created by David A. Huffman while he was a Sc.D. student at MIT, is used to find or use such a code. It was first published in the 1952 publication “A Method for the Construction of Minimum-Redundancy Codes.”</p>
<p>Huffman’s approach produces what is essentially a variable-length code table for encoding a source symbol (such as a character in a file). The estimated frequency of occurrence for each potential value of the source symbol is what the algorithm uses to create this table. Commoner symbols are typically represented using fewer bits than less common symbols. If the inputs are sorted, Huffman’s approach can be applied quickly, discovering a code in a time that is proportional to the number of inputs. Even though it is not the best compression method, it was released in 1952, making it a fairly algorithm that was widely used in specific research purpose or commercial purpose such as WinZip compression tool and JPEG, PNG picture format.</p>
<h3 id="Step-by-Step-Explanation"><a href="#Step-by-Step-Explanation" class="headerlink" title="Step by Step Explanation"></a>Step by Step Explanation</h3><h4 id="Read-file-from-source-and-extract"><a href="#Read-file-from-source-and-extract" class="headerlink" title="Read file from source and extract"></a>Read file from source and extract</h4><p>In order to describe the Huffman method in detail, step by step, I used the programming language Python. Note that this is not the greatest way for optimizing these codes such that they can take up more space and need more time to encode. This paper is just to explain how Huffman coding works.</p>
<p>First, In the Figure 1.1, I made a new text file. I want Python to read the strings in ASCII format. And put all of the information in the txt file to a variable: <mark class="hl-label blue">my_string</mark> . I need to get the total length of the code to do the next step.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">my_string = file.read()</span><br><span class="line">len_my_string = <span class="built_in">len</span>(my_string)</span><br><span class="line"><span class="comment">#Figure1.1: Ask python to read the txt file named data.txt and put all information in a new string called my_string and get its length</span></span><br></pre></td></tr></table></figure>

<p>Because the text file contains more than 2,700 characters, I will use the short string as an example(Figure1.2) in this paper.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_string = <span class="string">&quot;ahwderghs&quot;</span></span><br><span class="line"><span class="comment">#Figure 1.2: Using this variable my_string as an example in paper</span></span><br></pre></td></tr></table></figure>

<h4 id="Count-letters"><a href="#Count-letters" class="headerlink" title="Count letters"></a>Count letters</h4><p>We need to find some of the unique letters. We don’t want to store lots of duplicated letters in a new array list. Also, I used a <mark class="hl-label blue">count()</mark>  built-in Python function, which allows me to count how many times they appear in my string(Figure 2.1).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">letters = []</span><br><span class="line">only_letters = []</span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> my_string:</span><br><span class="line">    <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> letters:</span><br><span class="line">        freq = my_string.count(letter)</span><br><span class="line">        letters.append(freq)</span><br><span class="line">        letters.append(letter)</span><br><span class="line">        only_letters.append(letter)</span><br><span class="line"><span class="comment">#Figure 2.1: A code block of checking the unique letters and their frequently</span></span><br></pre></td></tr></table></figure>


<h4 id="Build-leafs-and-nodes"><a href="#Build-leafs-and-nodes" class="headerlink" title="Build leafs and nodes"></a>Build leafs and nodes</h4><p>After we get all the letters count and unique letters in the arrays, we start to build the Huffman tree (Figure 3.1), where we need to have some nodes. Make sure to order the tree in ascending order after adding all of the nodes huffman_tree[] array will be used as the final tree, and the nodes array will be used to combine and merge.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nodes = []</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(letters) &gt; <span class="number">0</span>:</span><br><span class="line">    nodes.append(letters[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">    letters = letters[<span class="number">2</span>:]</span><br><span class="line">nodes.sort()</span><br><span class="line">huffman_tree = []</span><br><span class="line">huffman_tree.append(nodes)</span><br><span class="line"><span class="comment">#Figure 3.1: A code block of building a Huffman Tree base and their nodes</span></span><br></pre></td></tr></table></figure>

<p>This is a recursive function (Figure3.2) to repeat the call to build the tree from the root all the way to the last leaf. Make sure it is in ascending order before starting to build. We want to ensure the two nodes are the smallest as the Huffman algorithm is a greedy method. We need to make sure all the things are the best optimized.</p>
<p>Let’s take the <mark class="hl-label blue">nodes[pos]</mark>  as the left nodes and <mark class="hl-label red">nodes[pos+1]</mark>  as the right nodes. And we want to append other elements. </p>
<div class="note modern"><p>For example, the <mark class="hl-label blue">node[pos] = [1, ‘a’, 0]</mark>  as the left side. The <mark class="hl-label red">node[pos+1] = [2, ‘h’, 1]</mark>  is the right side. Take them as the binary codes 0 and 1.</p>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#this is a recursive function that combines all the letters with the frequency count for each of those letters. It will keep recurse until the length of the nodes is less than 1.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">nodes</span>):</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    newnode = []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nodes) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment">#before each iteration of the recursive process, we have to check that the nodes are arranged in ascending order.</span></span><br><span class="line">        nodes.sort()</span><br><span class="line">        <span class="comment">#We add 0 and 1 on each node, where the first node (located on the left side) is 0, and the second node (located on the right side) is 1.</span></span><br><span class="line">        nodes[pos].append(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        nodes[pos + <span class="number">1</span>].append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="comment">#we start to combine the nodes. for example: nodes = [[1,&quot;a&quot;],[2,&quot;h&quot;]]</span></span><br><span class="line">        <span class="comment">#we combine the first and the second nodes of its elements together. Their frequently count number combine together: 1 + 2 =3</span></span><br><span class="line">        combined_node1 = nodes[pos][<span class="number">0</span>] + nodes[pos + <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># we combine the first and second nodes of its letter, which is &quot;a&quot; and &quot;h&quot; combined to form &quot;ah.&quot;</span></span><br><span class="line">        combined_node2 = nodes[pos][<span class="number">1</span>] + nodes[pos + <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># We create a new node by combining these two existing nodes into a single one. We store newly created nodes in the newnode[]. newnode = [3, &quot;ah&quot;]</span></span><br><span class="line">        newnode.append(combined_node1)</span><br><span class="line">        newnode.append(combined_node2)</span><br><span class="line">        <span class="comment">#we are now adding the new nodes together with the rest of the nodes that we haven&#x27;t used before. We should also need to remove the old nodes that were combined earlier.</span></span><br><span class="line">        <span class="comment">#it will end up looking something like this: [[3, &quot;ah], [3,&quot;g&quot;], [5, &quot;s&quot;]...] The first element (node) is the newly combined node that we just completed. and the remaining ones make up the older nodes.</span></span><br><span class="line">        newnodes = []</span><br><span class="line">        newnodes.append(newnode)</span><br><span class="line">        newnodes = newnodes + nodes[<span class="number">2</span>:]</span><br><span class="line">        <span class="comment">#after that, update the nodes with the new nodes, which are [3, &quot;ah&quot;] as well as those old nodes. This is going to be used once more for the subsequent recrusive.</span></span><br><span class="line">        nodes = newnodes</span><br><span class="line">        huffman_tree.append(nodes)</span><br><span class="line">        <span class="comment">#recursion will be called again until the nodes[] is less than 1</span></span><br><span class="line">        combine(nodes)</span><br><span class="line">        <span class="comment"># after the recursion is done, return to the huffman_tree with different nodes combined together</span></span><br><span class="line">        <span class="keyword">return</span> huffman_tree</span><br><span class="line"><span class="comment">#call this recursion funciton to recurse the nodes[]</span></span><br><span class="line">newnodes = combine(nodes)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Figure 3.2: A code block of a recursive function to be called to combine nodes in Huffman Tree</span></span><br></pre></td></tr></table></figure>

<h4 id="Tree-built-but-need-revision"><a href="#Tree-built-but-need-revision" class="headerlink" title="Tree built but need revision"></a>Tree built but need revision</h4><p>Then we start to combine these two nodes with the least values in the huffman_tree array. So it will become something like this: newnode = [3, ‘ah’]. Then we keep combining and combining again until the length of the nodes [] has one element left. The, we return to the final Huffman tree.</p>
<p><img src="/images/Algorithm/Huffman_Tree_Unreverse.png" title="Figure 3.3: Example of what the Huffman tree looks like after combing."></p>
<p>This is what the final tree looks like, but in Figure 3.3, it doesn’t seem correct because the tree root should be at the top where those leaves are supposed to be at the bottom. So we need another built-in python function to reverse the whole tree (Figure 3.5). </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huffman_tree.sort(reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Algorithm/Huffman_Tree_Reversed.png" title="Figure 3.5 Reversed sorting Huffman tree"></p>
<h4 id="Remove-Duplicated-elements"><a href="#Remove-Duplicated-elements" class="headerlink" title="Remove Duplicated elements"></a>Remove Duplicated elements</h4><p>However, we noticed lots of duplicated elements in the tree (Figure 3.5) where the Huffman tree does not accept duplicated nodes in the tree same as the Binary Search Tree algorithm. So, we need to remove those redundant elements.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checklist = []</span><br><span class="line"><span class="keyword">for</span> level <span class="keyword">in</span> huffman_tree:</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> level:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> checklist:</span><br><span class="line">            checklist.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            level.remove(node)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Figure 3.6: Remove duplicated element algorithm</span></span><br></pre></td></tr></table></figure>

<p>After we remove those duplicated elements by using an algorithm in Figure 3.6, we can move forward and encode those English letters into binary code. In figure 3.7, the loop will check if the targeted letter exists in each node. If the letter exists in these nodes, it will note them down; if the letter does not exist in these nodes, it will note down an empty value: “” with nothing inside the quotation marks.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#after that, we begin the process of converting these letters into our own unique binary code using the shortest amount of space possible (greedy method)</span></span><br><span class="line">letter_binary = []</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(only_letters) == <span class="number">1</span>:</span><br><span class="line">    letter_code = [only_letters[<span class="number">0</span>], <span class="string">&quot;0&quot;</span>]</span><br><span class="line">    letter_binary.append(letter_code * <span class="built_in">len</span>(my_string))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># this will check to see if the letter contains each of the nodes and then proceed accordingly. In the event that it does contain, add the binary value of the nodes, which can be found in the third position of the index.</span></span><br><span class="line">    <span class="comment"># If it does not contain anything, simply add the character sequence &quot;&quot; which is a string empty of any content and enclosed in quotation marks.</span></span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> only_letters:</span><br><span class="line">        lettercode = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> checklist:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(node) &gt; <span class="number">2</span> <span class="keyword">and</span> letter <span class="keyword">in</span> node[<span class="number">1</span>]:</span><br><span class="line">                lettercode = lettercode + node[<span class="number">2</span>]</span><br><span class="line">        letter_code = [letter, lettercode]</span><br><span class="line">        letter_binary.append(letter_code)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Figure 3.7: Converting the letters to binary codes by using the Huffman tree.</span></span><br></pre></td></tr></table></figure>

<h4 id="Get-our-own-ASCII-table-and-binary-codes"><a href="#Get-our-own-ASCII-table-and-binary-codes" class="headerlink" title="Get our own ASCII table and binary codes"></a>Get our own ASCII table and binary codes</h4><p>Now we get a table with Huffman algorithm, use this array and its element to convert our English text to the binary code. Converting algorithm can be seen below:</p>
<div class="note modern"><p>[[‘a’, ‘1110’], [‘h’, ‘01’], [‘w’, ‘110’], [‘d’, ‘1111’], [‘e’, ‘000’], [‘r’, ‘100’], [‘g’, ‘001’], [‘s’, ‘101’]]</p>
</div>

<h4 id="Encoding-by-using-our-own-ASCII-table"><a href="#Encoding-by-using-our-own-ASCII-table" class="headerlink" title="Encoding by using our own ASCII table"></a>Encoding by using our own ASCII table</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bitstring = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> my_string:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> letter_binary:</span><br><span class="line">        <span class="keyword">if</span> character <span class="keyword">in</span> item:</span><br><span class="line">            bitstring = bitstring + item[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Get-the-encoded-string"><a href="#Get-the-encoded-string" class="headerlink" title="Get the encoded string"></a>Get the encoded string</h4><p>Then we get a binary code with a very short length. Compared to the file size with ASCII table size is 72 bits, and we compressed it to the size of 27 bits. The size is reduced to 62% which is a very efficient algorithm to use. </p>
<div class="note modern"><p>111001110111100010000101101</p>
</div>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://ahui9605.github.io">Zehui Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://ahui9605.github.io/">https://ahui9605.github.io/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Articles/">Articles</a><a class="post-meta__tags" href="/tags/Code/">Code</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="/images/Logo/Algorithm_Logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-by-Step-Explanation"><span class="toc-text">Step by Step Explanation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-file-from-source-and-extract"><span class="toc-text">Read file from source and extract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Count-letters"><span class="toc-text">Count letters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Build-leafs-and-nodes"><span class="toc-text">Build leafs and nodes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tree-built-but-need-revision"><span class="toc-text">Tree built but need revision</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Remove-Duplicated-elements"><span class="toc-text">Remove Duplicated elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Get-our-own-ASCII-table-and-binary-codes"><span class="toc-text">Get our own ASCII table and binary codes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Encoding-by-using-our-own-ASCII-table"><span class="toc-text">Encoding by using our own ASCII table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Get-the-encoded-string"><span class="toc-text">Get the encoded string</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Zehui Liu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="#">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>